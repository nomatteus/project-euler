# Problem 12
# 08 March 2002

# The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
# The first ten terms would be:

#       1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred
# divisors?

# See 0008-reference.txt for info on finding factors & prime factors
import math


def triangle_number(n):
    """
    Calculate the nth triangle number, and return it
    """
    sum = 0
    for i in range(1, n + 1):
        sum += i
    return sum


assert 1 == triangle_number(1)
assert 3 == triangle_number(2)
assert 6 == triangle_number(3)
assert 10 == triangle_number(4)
assert 15 == triangle_number(5)
assert 21 == triangle_number(6)
assert 28 == triangle_number(7)
assert 36 == triangle_number(8)
assert 45 == triangle_number(9)
assert 55 == triangle_number(10)


def factorize(num):
    """
    Returns a set of the factors of the specified `num`

    Think about: How could this method be optimized?
    One way would be to store a list of factors as they are calculated, so
      we don't have to calculate the same factor twice.
    """
    factors = [1, num]  # 1 and the number itself are always factors (for num=1, dupes will get filtered out)
    for i in range(2, int(math.ceil(num / 2)) + 1):  # Can probably optimize this to a smaller range, maybe the ceil of num/2?
        if num % i == 0:
            factors.append(i)
    return set(factors)

assert set([1]) == factorize(1)
assert set([1, 3]) == factorize(3)
assert set([1, 2, 3, 6]) == factorize(6)
assert set([1, 2, 5, 10]) == factorize(10)
assert set([1, 3, 5, 15]) == factorize(15)
assert set([1, 3, 7, 21]) == factorize(21)
assert set([1, 2, 4, 7, 14, 28]) == factorize(28)


def problem_12(start_search, end_search):
    # iterate through triangle numbers, calculate the divisors of each,
    # until one is found with more than 500 divisors
    max_divisors = 0  # This will help figure out how close I am to an answer
    for i in range(start_search, end_search + 1):
        triangle_num = triangle_number(i)
        divisors = factorize(triangle_num)
        len_divisors = len(divisors)
        if i % 100 == 0:
            print "processing at %sth triangle number: %s" % (i, triangle_num)
            print "max_divisors so far: %s" % max_divisors
        if len_divisors > max_divisors:
            max_divisors = len_divisors
        if len_divisors > 500:
            return triangle_num
    print "max_divisors: %s" % max_divisors
    return None

# Tweak the parameters when searching for the answer, unless you want to
# run all the numbers every time!
answer = problem_12(12300, 15000)

print "The answer is %s" % answer
